=pod

=head1 NAME

SSL_set1_client_cert_type,
SSL_set1_server_cert_type,
SSL_CTX_set1_client_cert_type,
SSL_CTX_set1_server_cert_type,
SSL_get0_client_cert_type,
SSL_get0_server_cert_type,
SSL_CTX_get0_client_cert_type,
SSL_CTX_get0_server_cert_type - certificate type (RFC7250) support

=head1 SYNOPSIS

 #include <openssl/ssl.h>

 int SSL_set1_client_cert_type(SSL *s, const unsigned char *val, size_t len);
 int SSL_set1_server_cert_type(SSL *s, const unsigned char *val, size_t len);
 int SSL_CTX_set1_client_cert_type(SSL_CTX *ctx, const unsigned char *val, size_t len);
 int SSL_CTX_set1_server_cert_type(SSL_CTX *ctx, const unsigned char *val, size_t len);
 int SSL_get0_client_cert_type(SSL *s, unsigned char **val, size_t *len);
 int SSL_get0_server_cert_type(SSL *s, unsigned char **val, size_t *len);
 int SSL_CTX_get0_client_cert_type(SSL_CTX *ctx, unsigned char **val, size_t *len);
 int SSL_CTX_get0_server_cert_type(SSL_CTX *s, unsigned char **val, size_t *len);

=head1 DESCRIPTION

The SSL_set1_client_cert_type() and SSL_CTX_set1_client_cert_type() set the
values for the client certificate type extension. The SSL_get0_client_cert_type()
and SSL_CTX_get0_client_cert_type() retreive the local values to be used in the client
certificate type extension.

The SSL_set1_server_cert_type() and SSL_CTX_set1_server_cert_type() set the
values for the server certificate type extension. The SSL_get0_server_cert_type()
and SSL_CTX_get0_server_cert_type() retreive the local values to be used in the server
certificate type extension.

=head1 NOTES

The certificate type extensions are used to negotiate the certificate type to be
used in the handshake. These extentions act as notifications, and let each side
know what its peer is able to accept.

The client certificate type is sent from the client to the server to indicate what
certificate types the client accepts. Values are configured in preference order.
The values on the server are used to determine what the server will prefer to do.

The server certificate type is sent from the server to the client to indicate what
certificate types the server accepts. Values are configured in preference order.
The values on the client are used to determine what the client will prefer to do.

Having RPK specified first means that side will attempt to send RPKs if its peer
also supports RPKs, otherwise X.509 certificate will be used if both have specified
that (or have not configured these options).

The two supported values in the B<val> array are:

=over 4

=item TLSEXT_cert_type_x509

Which corresponds to an X.509 certificate normally used in TLS.

=item TLSEXT_cert_type_rpk

Which corresponds to a raw public key.

=back

If B<val> is set to a non-NULL value, then the extension is sent in the handshake.
If b<val> is set to a NULL value (and B<len> is 0), then the extension is
disabled. The default value is NULL, meaning the extension is not sent, and
X.509 certificates are used in the handshake.

Raw public keys may be used in place of certificates when specified in the
certificate type and negotiated.
Raw public keys have no subject, issuer, validity dates nor digital signature.

Use the SSL_get_negotiated_client_cert_type(3) and SSL_get_negotiated_server_cert_type(3)
to get the negotiated cert type values.

=head1 RETURN VALUES

All functions return 1 on success and 0 on failure.

The memory returned from the get0 functions must not be freed.

=head1 EXAMPLES

To use raw public keys on the server, set up the SSL_CTX and SSL as follows:

 SSL_CTX *ctx;
 SSL *ssl;
 unsigned char cert_type[] = { TLSEXT_cert_type_rpk };
 EVP_PKEY *rpk;

 /* Assign rpk to an EVP_PKEY from a file or other means */

 if ((ctx = SSL_CTX_new(TLS_server_method())) == NULL)
     /* error */
 if ((ssl = SSL_new(ctx)) == NULL)
     /* error */
 if (!SSL_set1_server_cert_type(ssl, cert_type, sizeof(cert_type)))
     /* error */

 /* A certificate does not need to be specified when using raw public keys */
 if (!SSL_use_PrivateKey(ssl, rpk))
     /* error */

 /* Perform SSL_accept() operations */

To connect to this server, set the client SSL_CTX and SSL as follows:

 int verify_cb(int ok, X509_STORE_CTX *sctx)
 {
     X509 *x509;
     EVP_PKEY *rpk;

     x509 = X509_STORE_CTX_get0_cert(sctx);
     if (x509 != NULL) {
        /* Verifying a certificate */
     }
     rpk = X509_STORE_CTX_get0_rpk(sctx);
     if (rpk != NULL) {
         /* Verifying a raw public key */
     }
     return ok;
 }

 /* Connect function */

 SSL_CTX *ctx;
 SSL *ssl;
 const char *nexthop_domain = "example.com";
 const char *dane_tlsa_domain = "smtp.example.com";
 unsigned char cert_type[] = { TLSEXT_cert_type_rpk };
 EVP_PKEY *rpk;
 int verify_result;

 /* Assign rpk to an EVP_PKEY from a file or other means */

 if ((ctx = SSL_CTX_new(TLS_client_method())) == NULL)
     /* error */
 if (SSL_CTX_dane_enable(ctx) <= 0)
     /* error */
 if ((ssl = SSL_new(ctx)) == NULL)
     /* error */
 if (SSL_dane_enable(ssl, dane_tlsa_domain) <= 0)
     /* error */
 if (!SSL_set1_server_cert_type(ssl, cert_type, sizeof(cert_type)))
     /* error */
 if (!SSL_add_expected_rpk(ssl, rpk, nid_undef))
     /* error */

 /* Set a verify callback if desired */
 SSL_set_verify(ssl, SSL_VERIFY_PEER, verify_cb);

 /* Do SSL_connect() handshake and handle errors here */

 verify_result = SSL_get_verify_result(ssl);
 if (verify_result == X509_V_OK) {
     /* Server's raw public key matched the TLSA record */
 } else if (verify_result == X509_V_ERR_DANE_NO_MATCH) {{
     /* Server's raw public key did not match the TLSA record */
 } else {
     /* Some other verify error */
 }

To validate client raw public keys, code from the client example may need to be
incorporated into the server side.

=head1 SEE ALSO

L<SSL_get0_peer_rpk(3)>,
L<SSL_get_negotiated_client_cert_type(3)>,
L<SSL_get_negotiated_server_cert_type(3)>,
L<SSL_use_certificate(3)>

=head1 HISTORY

These functions were added in OpenSSL 3.2.

=head1 COPYRIGHT

Copyright 2022 The OpenSSL Project Authors. All Rights Reserved.

=cut
